<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <title>Sorting Algorithms Visualizer</title>
  <link rel="icon" type="image/x-icon" href="images/favicon.ico">
  <script src="https://cdn.tailwindcss.com"></script>
  <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/brython@3.9.5/brython.min.js"></script>
  <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/brython@3.9.5/brython_stdlib.js"></script>
  <style>
    .warning {
      display: none;
      color: red;
      font-size: 0.9em;
    }
    .bar {
    position: absolute;
    bottom: 0;
    background-color: #4CAF50;
    transition: left 0.3s ease, height 0.3s ease, background-color 0.2s;
    border-radius: 3px 3px 0 0;
    }
    .array-container {
      position: relative;
      height: 120px;
      margin-bottom: 15px;
      border-bottom: 1px solid #ddd;
      padding-bottom: 5px;
    }
    .array-label {
      position: relative;
      font-weight: bold;
      font-size: 14px;
      margin-bottom: 5px;
      text-align: left;
      color: #004d40;
    }
    .section {
    display: flex;
    flex-direction: column;
    min-width: 20%;
    flex: 1;
    border: 1px solid #ccc;
    padding: 15px;
    box-sizing: border-box;
    background: #fafafa;
    border-radius: 8px;
    margin: 5px;
    }
    .section-title {
      font-weight: bold;
      font-size: 1.2em;
      margin-bottom: 15px;
      border-bottom: 2px solid #00796b;
      color: #00796b;
      padding-bottom: 8px;
    }
    .memory-layout {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      align-items: flex-start;
      gap: 20px;
      width: 100%;
      padding: 10px;
      overflow-y: auto;
    }
    .memory-container {
      width: 100%;
      min-height: 400px;
      overflow-y: auto;
      padding: 10px;
      position: relative;
    }
    .arrow-svg {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 10;
    }
  </style>
</head>

<body onload="brython(); updateInputVisibility();" class="bg-blue-50">
  <div class="container mx-auto px-2 py-8">
    
    <div class="text-center mb-8 pb-4">
        <h1 class="text-4xl font-extrabold bg-gradient-to-r from-teal-600 via-cyan-600 to-blue-600 bg-clip-text text-transparent mb-3 pb-1 leading-tight">
        Sorting Algorithm Visualizer
        </h1>
        <div class="w-32 h-1 bg-gradient-to-r from-teal-500 to-cyan-500 mx-auto rounded-full mb-2"></div>
        <p class="text-lg text-gray-600 font-medium">Interactive visualization of sorting algorithms in secondary memory</p>
    </div>

    <div class="flex flex-col lg:flex-row gap-3">
      <div id="inputSection" class="bg-white p-6 rounded-lg shadow-md w-full lg:w-1/5 flex flex-col h-full">
        <div class="mb-4">
          <label for="sortMethod" class="block font-bold text-teal-700 mb-2">Sorting method:</label>
          <select id="sortMethod" onchange="updateInputVisibility()" class="w-full p-2 border rounded">
            <option value="k-way">K-Way Merge Sort</option>
            <option value="bubble">Bubble Sort</option>
            <option value="insertion">Insertion Sort</option>
          </select>
        </div>

        <div id="arrayInputFields" class="mb-4">
          <label for="arrayInput" class="block font-bold text-teal-700 mb-2">Input array:</label>
          <input type="text" id="arrayInput" placeholder="Enter numbers e.g. 5,3,8,6" oninput="validateIntegerList(this)" class="w-full p-2 border rounded">
          <span class="warning" id="arrayInputWarning">Please enter only comma-separated integers.<br></span>
        </div>

        <div id="kWayFields" style="display: none;" class="space-y-4">
          <div>
            <label for="n_pages" class="block font-bold text-teal-700 mb-2">Number of pages:</label>
            <input type="text" id="n_pages" placeholder="e.g. 6" oninput="validateInteger(this)" class="w-full p-2 border rounded">
            <span class="warning" id="n_pagesWarning">Please enter a valid integer.<br></span>
          </div>

          <div>
            <label for="n_frames" class="block font-bold text-teal-700 mb-2">Number of frames in the buffer:</label>
            <input type="text" id="n_frames" placeholder="e.g. 3 (2-way-sort)" oninput="validateInteger(this)" class="w-full p-2 border rounded">
            <span class="warning" id="n_framesWarning">Please enter a valid integer.<br></span>
          </div>

          <div>
            <label for="elements_per_page" class="block font-bold text-teal-700 mb-2">Elements per page/frame:</label>
            <input type="text" id="elements_per_page" placeholder="e.g. 8" oninput="validateInteger(this)" class="w-full p-2 border rounded">
            <span class="warning" id="elements_per_pageWarning">Please enter a valid integer.<br></span>
          </div>

          <div class="flex items-center">
            <input type="checkbox" id="manual_populate" oninput="updatePageInputs()" class="mr-2">
            <label for="manual_populate" class="font-bold text-teal-700">Manually populate pages</label>
          </div>

          <div id="pageInputsContainer"></div>
        </div>

        <div class="flex gap-2 mt-4">
        <button onclick="run_sort()" class="flex-1 bg-teal-600 hover:bg-teal-700 text-white font-bold py-2 px-4 rounded transition-colors">
            Run
        </button>
        <button id="stopResumeBtn" onclick="toggleAnimation()" disabled class="flex-1 bg-gray-400 text-white font-bold py-2 px-4 rounded transition-colors cursor-not-allowed">
            Stop
        </button>
        </div>

        <div class="mt-6">
          <label for="speedRange" class="block font-bold text-teal-700 mb-2">Animation Speed (ms):</label>
          <input type="range" id="speedRange" min="50" max="1000" value="500" step="50" oninput="updateSpeedDisplay()" class="w-full">
          <span id="speedValue" class="text-teal-700">500 ms</span>
        </div>

        <div class="mt-6">
        <label class="block font-bold text-teal-700 mb-2">Logs:</label>
        <div id="console" class="w-full h-32 p-2 border rounded bg-gray-100 overflow-y-auto text-sm font-mono"></div>
        </div>
      </div>

      <div id="container" class="relative bg-white p-4 rounded-lg shadow-md flex-1 min-h-[400px] flex items-center justify-center memory-container">
        <p class="text-gray-500">Select a sorting method and input data to see the visualization</p>
      </div>

    </div>
  </div>

  <script type="text/python">
from browser import document, html, timer, alert, window
import random
import copy
import math

bar_max_height = 100
height_per_block = 150
current_arrows = {}


###########
# UTILITY #
###########

def preprocess_highlight(state, highlight):
    expanded_highlight = set()
    for section, arrays in state.items():
        for i, arr in enumerate(arrays):
            for hl in highlight:
                sec, idx, bar = hl
                if sec == section and idx == i:
                    if bar == "all":
                        for j in range(len(arr)):
                            expanded_highlight.add((sec, i, j))
                    elif isinstance(bar, int):
                        expanded_highlight.add((sec, i, bar))
    return expanded_highlight


def create_section(title_text, content_elements, height_px=None):
    section = html.DIV(Class="section")
    title = html.H3(title_text, Class="section-title")
    section <= title
    for elem in content_elements:
        section <= elem
    return section


def render_array(arr, label, base_id, max_val, run_info=None):
    array_container = html.DIV(Class="array-container")
    array_container.id = f"{base_id}-container"
    
    if label:
        array_label = html.DIV(label, Class="array-label")
        array_container <= array_label

    # Calculate width and spacing as percentage of container
    num_bars = len(arr)
    if num_bars > 0:
        bar_width_percent = 80 / num_bars  # Use 80% of container, leaving 20% for spacing
        spacing_percent = 20 / (num_bars + 1)  # Distribute remaining 20% as spacing
    else:
        bar_width_percent = 0
        spacing_percent = 0

    for i, val in enumerate(arr):
        height = (val / max_val) * bar_max_height
        left_position = spacing_percent + i * (bar_width_percent + spacing_percent)
        
        bar = html.DIV(
            Class="bar",
            style={
                "height": f"{height}px",
                "left": f"{left_position}%",
                "width": f"{bar_width_percent}%"
            },
            id=f"{base_id}-bar-{i}"
        )
        array_container <= bar

    return array_container


def create_arrow_layer():
    """Create SVG layer for arrows"""
    svg = document.createElementNS("http://www.w3.org/2000/svg", "svg")
    svg.setAttribute("class", "arrow-svg")
    svg.id = "arrowLayer"
    
    # Create defs for arrowhead marker
    defs = document.createElementNS("http://www.w3.org/2000/svg", "defs")
    marker = document.createElementNS("http://www.w3.org/2000/svg", "marker")
    marker.setAttribute("id", "arrowhead")
    marker.setAttribute("markerWidth", "10")
    marker.setAttribute("markerHeight", "7")
    marker.setAttribute("refX", "9")
    marker.setAttribute("refY", "3.5")
    marker.setAttribute("orient", "auto")
    
    polygon = document.createElementNS("http://www.w3.org/2000/svg", "polygon")
    polygon.setAttribute("points", "0 0, 10 3.5, 0 7")
    polygon.setAttribute("fill", "#000000")
    
    marker.appendChild(polygon)
    defs.appendChild(marker)
    svg.appendChild(defs)
    
    return svg


def draw_arrow(from_id, to_id, arrow_id):
    """Draw arrow between two elements"""
    from_el = document.getElementById(from_id)
    to_el = document.getElementById(to_id)
    
    if not from_el or not to_el:
        return
    
    svg = document.getElementById("arrowLayer")
    if not svg:
        return
    
    # Remove existing arrow if it exists
    existing_arrow = document.getElementById(arrow_id)
    if existing_arrow:
        existing_arrow.remove()
    
    # Get container bounds for relative positioning
    container = document.getElementById("container")
    container_rect = container.getBoundingClientRect()
    
    # Get element bounds
    from_rect = from_el.getBoundingClientRect()
    to_rect = to_el.getBoundingClientRect()
    
    # Calculate relative positions
    x1 = from_rect.left - container_rect.left + from_rect.width
    y1 = from_rect.top - container_rect.top + from_rect.height / 2
    x2 = to_rect.left - container_rect.left
    y2 = to_rect.top - container_rect.top + to_rect.height / 2
    
    # Create arrow line
    line = document.createElementNS("http://www.w3.org/2000/svg", "line")
    line.setAttribute("id", arrow_id)
    line.setAttribute("x1", str(x1))
    line.setAttribute("y1", str(y1))
    line.setAttribute("x2", str(x2))
    line.setAttribute("y2", str(y2))
    line.setAttribute("stroke", "#000000")
    line.setAttribute("stroke-width", "3")
    line.setAttribute("marker-end", "url(#arrowhead)")
    line.setAttribute("opacity", "0.8")
    
    svg.appendChild(line)
    current_arrows[arrow_id] = line


def remove_arrow(arrow_id):
    """Remove an arrow"""
    if arrow_id in current_arrows:
        current_arrows[arrow_id].remove()
        del current_arrows[arrow_id]


def clear_all_arrows():
    """Clear all arrows"""
    for arrow_id in list(current_arrows.keys()):
        remove_arrow(arrow_id)


def log_to_console(message, newline=True):
    """
    Log a message to the console display.
    If newline=False, the message will be added to the current line.
    """
    console = document["console"]
    if newline:
        console.innerHTML += f"<div>{message}</div>"
    else:
        # Get the last div or create one if none exists
        divs = console.querySelectorAll("div")
        if divs.length > 0:
            last_div = divs[divs.length - 1]
            last_div.innerHTML += f" {message}"
        else:
            console.innerHTML += f"<div>{message}</div>"
    console.scrollTop = console.scrollHeight


#######################
# MAIN MEMORY SORTING #
#######################

def main_create_bars(arr):
    """
    Create bars for main memory sorting.
    """
    container = document["container"]
    container.clear()
    container.style["backgroundColor"] = "#e0f7fa"

    height = 100 + height_per_block
    max_val = max(arr) if arr else 1

    # create section
    main_elements = []
    main_elements.append(render_array(arr, None, f"main", max_val))

    main_memory_section = create_section("Main Memory", main_elements)

    # Create flexible layout
    layout = html.DIV(Class="memory-layout")
    layout <= main_memory_section

    container <= layout


def main_update_bars(arr, highlight=[]):
    """
    Update bars for main memory soring.
    """
    max_val = max(arr) if arr else 1
    
    # Calculate width and spacing as percentage
    num_bars = len(arr)
    if num_bars > 0:
        bar_width_percent = 80 / num_bars
        spacing_percent = 20 / (num_bars + 1)
    else:
        bar_width_percent = 0
        spacing_percent = 0

    for i, val in enumerate(arr):
        bar_id = f"main-bar-{i}"
        bar = document.getElementById(bar_id)

        height = (val / max_val) * 100
        left_position = spacing_percent + i * (bar_width_percent + spacing_percent)
        
        bar.style.left = f"{left_position}%"
        bar.style.width = f"{bar_width_percent}%"
        bar.style.height = f"{height}px"
        bar.style.backgroundColor = "#FF5733" if i in highlight else "#4CAF50"


def main_animate(steps):
    i = 0
    def update():
        nonlocal i
        if i < len(steps):
            paused = window.animationPaused if hasattr(window, 'animationPaused') else False
            if not paused:
                if len(steps[i]) == 3:  # New format with log
                    state, highlight, log_message = steps[i]
                else:  # Old format without log
                    state, highlight = steps[i]
                    log_message = None
                
                main_update_bars(state, highlight)
                if log_message:
                    log_to_console(log_message)
                
                i += 1
                if i < len(steps):
                    speed = int(document["speedRange"].value)
                    timer.set_timeout(update, speed)
                else:
                    window.disableStopButton()
            else:
                timer.set_timeout(update, 100)
    
    window.enableStopButton()
    update()


def main_bubble_sort(arr, callback):
    """
    Main memory Bubblesort
    """
    steps = []

    def record(a, highlight=[], log_message=None):
        steps.append((a[:], highlight[:], log_message))

    a = arr[:]
    n = len(a)
    for i in range(n):
        for j in range(n - i - 1):
            if a[j] > a[j + 1]:
                a[j], a[j + 1] = a[j + 1], a[j]
                record(a, [j, j + 1])

    record(a)
    callback(steps)


def main_insertion_sort(arr, callback):
    """
    Main memory insertion sort.
    """
    steps = []

    def record(a, highlight=[], log_message=None):
        steps.append((a[:], highlight[:], log_message))

    a = arr[:]
    for i in range(1, len(a)):
        key = a[i]
        j = i - 1
        while j >= 0 and key < a[j]:
            a[j + 1] = a[j]
            j -= 1
            record(a, [j + 1, j + 2])
        a[j + 1] = key
        record(a, [j + 1])

    record(a)
    callback(steps)


############################
# SECONDARY MEMORY SORTING #
############################

def create_bars(input_pages, output_pages, frames):
    """
    Create bars for external sorting with separate input and output secondary memory.
    """
    container = document["container"]
    container.clear()
    container.style["backgroundColor"] = "#e0f7fa"
    
    # Clear existing arrows
    clear_all_arrows()

    # Calculate max value for scaling
    all_values = []
    for page in input_pages:
        all_values.extend(page)
    for page in output_pages:
        all_values.extend(page)
    for frame in frames:
        all_values.extend(frame)
    max_val = max(all_values) if all_values else 1

    # Create input secondary memory section
    input_elements = []
    for i, page in enumerate(input_pages):
        input_elements.append(render_array(page, f"Page {i+1}", f"input-page-{i}", max_val))

    input_secondary_memory_section = create_section("Secondary Memory - Input Pass 0", input_elements)

    # Create output secondary memory section
    output_elements = []
    for i, page in enumerate(output_pages):
        output_elements.append(render_array(page, f"Page {i+1}", f"output-page-{i}", max_val))

    output_secondary_memory_section = create_section("Secondary Memory - Output Pass 0", output_elements)

    # Create buffer section
    buffer_elements = []
    for i, frame in enumerate(frames):
        buffer_elements.append(render_array(frame, f"Frame {i+1}", f"frame-{i}", max_val))

    buffer_section = create_section("Buffer", buffer_elements)

    # Create flexible layout with buffer in the middle
    layout = html.DIV(Class="memory-layout")
    layout <= input_secondary_memory_section
    layout <= buffer_section
    layout <= output_secondary_memory_section

    # Add arrow layer
    svg = create_arrow_layer()
    
    container <= layout
    container <= svg


def update_bars(state, highlight=set()):
    expanded_highlight = preprocess_highlight(state, highlight)
    
    # Calculate max value for consistent scaling
    all_values = []
    for section, arrays in state.items():
        for arr in arrays:
            all_values.extend(arr)
    max_val = max(all_values) if all_values else 1
    
    for section, arrays in state.items():
        for i, arr in enumerate(arrays):
            for j, val in enumerate(arr):
                if section == "input_pages":
                    bar_id = f"input-page-{i}-bar-{j}"
                elif section == "output_pages":
                    bar_id = f"output-page-{i}-bar-{j}"
                elif section == "frames":
                    bar_id = f"frame-{i}-bar-{j}"
                else:
                    continue
                    
                bar = document.getElementById(bar_id)
                if bar:
                    height = (val / max_val) * bar_max_height
                    bar.style.height = f"{height}px"
                    bar.style.backgroundColor = "#FF5733" if (section, i, j) in expanded_highlight else "#4CAF50"


def animate(steps):
    i = 0
    def update():
        nonlocal i
        if i < len(steps):
            paused = window.animationPaused if hasattr(window, 'animationPaused') else False
            if not paused:
                state, highlight, arrows, log_message, swap, memory_run_info, buffer_run_info = steps[i]
                update_bars(state, highlight)
                
                if log_message:
                    log_to_console(log_message)
               
                # handle arrows
                if arrows:
                    for arrow_info in arrows:
                        if arrow_info["action"] == "draw":
                            speed = int(document["speedRange"].value)
                            delay = min(100, speed // 2)
                            timer.set_timeout(lambda: draw_arrow(arrow_info["from"], arrow_info["to"], arrow_info["id"]), delay)
                        elif arrow_info["action"] == "remove":
                            remove_arrow(arrow_info["id"])

                if swap:
                    sections = document.querySelectorAll('.section')
                    for section in sections:
                        title_element = section.querySelector('.section-title')
                        if title_element:
                            if 'Input Pass' in title_element.innerHTML:
                                title_element.innerHTML = f"Secondary Memory - Input Pass {swap}"
                            elif 'Output Pass' in title_element.innerHTML:
                                title_element.innerHTML = f"Secondary Memory - Output Pass {swap}"
                
                if memory_run_info:
                    if 'input' in memory_run_info:
                        for page_idx, run_num in memory_run_info['input'].items():
                            container = document.getElementById(f"input-page-{page_idx}-container")
                            if container:
                                label_element = container.querySelector('.array-label')
                                if label_element:
                                    label_element.innerHTML = f"Page {page_idx+1} (Run {run_num})"
                    
                    if 'output' in memory_run_info:
                        for page_idx, run_num in memory_run_info['output'].items():
                            container = document.getElementById(f"output-page-{page_idx}-container")
                            if container:
                                label_element = container.querySelector('.array-label')
                                if label_element:
                                    label_element.innerHTML = f"Page {page_idx+1} (Run {run_num})"
                
                if buffer_run_info:
                    for frame_idx, run_num in buffer_run_info.items():
                        container = document.getElementById(f"frame-{frame_idx}-container")
                        if container:
                            label_element = container.querySelector('.array-label')
                            if label_element:
                                if run_num == "output":
                                    label_element.innerHTML = f"Frame {frame_idx+1} (Output)"
                                else:
                                    label_element.innerHTML = f"Frame {frame_idx+1} (Run {run_num})"


                i += 1
                if i < len(steps):
                    speed = int(document["speedRange"].value)
                    timer.set_timeout(update, speed)
                else:
                    window.disableStopButton()
            else:
                timer.set_timeout(update, 100)

        if i >= len(steps):
            for section_idx, section in enumerate(document.querySelectorAll('.section')):
                title_element = section.querySelector('.section-title')
                if title_element and 'Output Pass' in title_element.innerHTML:
                    # Find all bars in this output section
                    bars = section.querySelectorAll('.bar')
                    for bar in bars:
                        bar.style.backgroundColor = "#4682B4"  # Light blue color

    window.enableStopButton()

    update()


def k_way_merge_sort(input_pages, output_pages, frames, n_pages, n_frames, elements_per_page, callback):

   steps = []
   frames = [[] for _ in range(n_frames)]
   
   def record(highlight=set(), arrows=None, log_message=None, swap=False, memory_run_info=None, buffer_run_info=None):
       input_pages_copy = copy.deepcopy(input_pages)
       output_pages_copy = copy.deepcopy(output_pages)
       frames_copy = copy.deepcopy(frames)
       highlight_copy = copy.deepcopy(highlight)
       arrows_copy = copy.deepcopy(arrows) if arrows else []
       steps.append(({"input_pages": input_pages_copy,
                      "output_pages": output_pages_copy,
                      "frames": frames_copy},
                     highlight_copy,
                     arrows_copy,
                     log_message,
                     swap,
                     memory_run_info,
                     buffer_run_info))

   record(log_message="Pass 0: sort each page.")

   for l in range(n_pages):
       # load page into frame
       frames[0] = copy.deepcopy(input_pages[l])

       arrow_info = [{
           "action": "draw",
           "from": f"input-page-{l}-container",
           "to": f"frame-0-container",
           "id": f"arrow-input-page-{l}-frame-0"
       }]

       record(highlight=(("input_pages", l, "all"),
                         ("frames", 0, "all")),
                         arrows=arrow_info,
                         log_message=f"Input {l+1} loaded in frame 1.")

       # sort the frame using bubble sort
       for i in range(len(frames[0])):
           for j in range(len(frames[0]) - i - 1):
               if frames[0][j] > frames[0][j + 1]:
                   frames[0][j], frames[0][j + 1] = frames[0][j + 1], frames[0][j]
                   record(highlight=(("frames", 0, j), ("frames", 0, j+1)))

       # write sorted frame to output page
       output_pages[l] = copy.deepcopy(frames[0])
       arrow_remove_input = [{
           "action": "remove",
           "id": f"arrow-input-page-{l}-frame-0"
       }]
       arrow_to_output = [{
           "action": "draw",
           "from": f"frame-0-container",
           "to": f"output-page-{l}-container",
           "id": f"arrow-frame-0-output-page-{l}"
       }]
       record(highlight=(("frames", 0, "all"),
                         ("output_pages", l, "all")),
                         arrows=arrow_remove_input + arrow_to_output,
                         log_message=f"Frame 1 written in output {l+1}.")
       
       # remove arrow to output after a brief moment
       arrow_remove_output = [{
           "action": "remove",
           "id": f"arrow-frame-0-output-page-{l}"
       }]
       record(arrows=arrow_remove_output)

   record(log_message="Pass 0 completed.")

   # merge passes
   k = n_frames - 1
   n_passes = math.ceil(math.log(n_pages, k))

   for pass_num in range(1, n_passes + 1):
       # get pass infos
       old_runs_size = k ** (pass_num - 1)
       current_runs_size = k ** pass_num

       # swap input and output secondary memory
       input_pages, output_pages = output_pages, input_pages
   
       # reset output page
       output_pages = [[0] * elements_per_page for _ in range(n_pages)]

       # Calculate run assignments for this pass
       input_run_assignments = {}
       output_run_assignments = {}

       for i in range(len(input_pages)):
           input_run_assignments[i] = (i // old_runs_size) + 1

       if pass_num == n_passes:  # final pass
           for i in range(len(output_pages)):
               output_run_assignments[i] = 1
       else:
           next_runs_size = k ** pass_num
           for i in range(len(output_pages)):
               output_run_assignments[i] = (i // next_runs_size) + 1

       run_info = {
           'input': input_run_assignments,
           'output': output_run_assignments
       }

       record(log_message=f"Starting Pass {pass_num}.", swap=pass_num, memory_run_info=run_info)

       # divide into runs
       runs = [input_pages[i:i + old_runs_size] for i in range(0, len(input_pages), old_runs_size)]

       # divide into executions
       executions = [runs[i:i + k] for i in range(0, len(runs), k)]

       output_page_idx = 0

       # perform each execution
       for exec_idx, execution in enumerate(executions):
           record(log_message=f"Starting Run {exec_idx+1}.")

           run_info = {}
           run_info[k] = "output"

           for frame in range(n_frames-1):
               run_info[frame] = k * exec_idx + frame + 1

           record(buffer_run_info=run_info)

           # Initialize frame pointers and page pointers for each run
           frame_pointers = [0] * len(execution)  # Points to current element in each frame
           page_pointers = [0] * len(execution)   # Points to current page in each run
           output_frame_pointer = 0
           
           # Track current arrow IDs for each frame
           current_arrow_ids = [None] * len(execution)
           
           # Initialize output frame with zeros
           frames[-1] = [0] * elements_per_page
           
           # load first page of each run into buffer frames
           for j in range(len(execution)):
               frames[j] = copy.deepcopy(execution[j][0])
               
               # Calculate the global page index for the first page of this run
               global_page_idx = exec_idx * k * old_runs_size + j * old_runs_size
               current_arrow_ids[j] = f"arrow-input-page-{global_page_idx}-frame-{j}"

               arrow_info = [{
                   "action": "draw",
                   "from": f"input-page-{global_page_idx}-container",
                   "to": f"frame-{j}-container",
                   "id": current_arrow_ids[j]
               }]

               record(highlight=(("input_pages", global_page_idx, "all"),
                               ("frames", j, "all")),
                               arrows=arrow_info,
                               log_message=f"Input {global_page_idx + 1} loaded in frame {j + 1}.")

           # perform merging pass
           # until there are no more elements left in any frame
           while any(frame_pointers[i] < len(frames[i]) or 
                    page_pointers[i] < len(execution[i]) - 1 
                    for i in range(len(execution))):

               # find minimum between first non-processed element of each input frame
               min_val = float('inf')
               min_frame = -1
               
               for i in range(len(execution)):
                   if frame_pointers[i] < len(frames[i]) and frames[i][frame_pointers[i]] != 0:
                       if frames[i][frame_pointers[i]] < min_val:
                           min_val = frames[i][frame_pointers[i]]
                           min_frame = i

               if min_frame == -1:
                   break

               # write minimum in the output frame and mark as processed in input frame
               frames[-1][output_frame_pointer] = min_val
               output_frame_pointer += 1
               
               record(highlight=(("frames", min_frame, frame_pointers[min_frame]),
                               ("frames", n_frames-1, output_frame_pointer-1)))
               
               frames[min_frame][frame_pointers[min_frame]] = 0
               frame_pointers[min_frame] += 1

               # if output frame is full write it in the output secondary memory and empty it
               if output_frame_pointer == elements_per_page:
                   output_pages[output_page_idx] = copy.deepcopy(frames[-1])
                   
                   arrow_to_output = [{
                       "action": "draw",
                       "from": f"frame-{n_frames-1}-container",
                       "to": f"output-page-{output_page_idx}-container",
                       "id": f"arrow-output-frame-page-{output_page_idx}"
                   }]
                   
                   record(highlight=(("frames", n_frames-1, "all"),
                                   ("output_pages", output_page_idx, "all")),
                          arrows=arrow_to_output,
                          log_message=f"Output page {output_page_idx + 1} written.")
                   
                   arrow_remove_output = [{
                       "action": "remove",
                       "id": f"arrow-output-frame-page-{output_page_idx}"
                   }]
                   record(arrows=arrow_remove_output)
                   
                   # Reset output frame with zeros
                   frames[-1] = [0] * elements_per_page
                   output_frame_pointer = 0
                   output_page_idx += 1

               # if an input frame is exhausted, load next page of the same run
               if frame_pointers[min_frame] >= len(frames[min_frame]):
                   if page_pointers[min_frame] < len(execution[min_frame]) - 1:
                       page_pointers[min_frame] += 1
                       page_in_run = page_pointers[min_frame]
                       global_page_idx = exec_idx * k * old_runs_size + min_frame * old_runs_size + page_in_run
                       
                       if global_page_idx < len(input_pages):
                           frames[min_frame] = copy.deepcopy(execution[min_frame][page_in_run])
                           frame_pointers[min_frame] = 0
                           
                           # Remove the current arrow using the tracked ID
                           arrow_remove_old = [{
                               "action": "remove",
                               "id": current_arrow_ids[min_frame]
                           }]
                           
                           # Create new arrow and update the tracked ID
                           new_arrow_id = f"arrow-input-page-{global_page_idx}-frame-{min_frame}"
                           current_arrow_ids[min_frame] = new_arrow_id
                           
                           arrow_new = [{
                               "action": "draw",
                               "from": f"input-page-{global_page_idx}-container",
                               "to": f"frame-{min_frame}-container",
                               "id": new_arrow_id
                           }]
                           
                           record(highlight=(("input_pages", global_page_idx, "all"),
                                           ("frames", min_frame, "all")),
                                  arrows=arrow_remove_old + arrow_new,
                                  log_message=f"Input {global_page_idx + 1} loaded in frame {min_frame + 1}.")

           # write remaining elements in output frame if any
           if output_frame_pointer > 0:
               output_pages[output_page_idx] = copy.deepcopy(frames[-1])
               
               arrow_to_output = [{
                   "action": "draw",
                   "from": f"frame-{n_frames-1}-container",
                   "to": f"output-page-{output_page_idx}-container",
                   "id": f"arrow-output-frame-page-{output_page_idx}"
               }]
               
               record(highlight=(("frames", n_frames-1, "all"),
                               ("output_pages", output_page_idx, "all")),
                      arrows=arrow_to_output,
                      log_message=f"Final output page {output_page_idx + 1} written.")
               
               arrow_remove_output = [{
                   "action": "remove",
                   "id": f"arrow-output-frame-page-{output_page_idx}"
               }]
               record(arrows=arrow_remove_output)
               
               output_page_idx += 1

           # remove all remaining input arrows for this execution
           for j in range(len(execution)):
               if current_arrow_ids[j]:  # Only remove if arrow exists
                   arrow_remove = [{
                       "action": "remove",
                       "id": current_arrow_ids[j]
                   }]
                   record(arrows=arrow_remove)

           record(log_message=f"Run {exec_idx+1} completed.")

       record(log_message=f"Pass {pass_num} completed.")

   record(log_message="Sorting completed.")

   callback(steps)


###############
# MAIN SCRIPT #
###############

def get_manual_inputs():
    n_pages = int(document["n_pages"].value)
    pages = []
    for i in range(1, n_pages + 1):
        input_id = f"page_{i}"
        if input_id in document:
            raw_input = document[input_id].value.strip()
            if raw_input:
                try:
                    numbers = [int(x.strip()) for x in raw_input.split(",")]
                    pages.append(numbers)
                except ValueError:
                    alert(f"Invalid input in Page {i}. Please enter only integers.")
                    return
            else:
                pages.append([])
        else:
            pages.append([])
    return pages


def on_sort_trigger(ev):
    method = document["sortMethod"].value
    document.getElementById("console").innerHTML = ""

    if method == "k-way":
        try:
            n_pages = int(document["n_pages"].value)
            n_frames = int(document["n_frames"].value)
            elements_per_page = int(document["elements_per_page"].value)
        except ValueError:
            alert("Please enter valid integers for all K-way merge sort parameters.")
            return

        if not document["manual_populate"].checked:
            input_pages = []
            for i in range(n_pages, 0, -1):
                # Different range for each page to create visual variety
                base = (i + 1) * elements_per_page * 3
                page_range = elements_per_page * 15
                lower = max(1, base - page_range // 2)
                upper = base + page_range // 2
                input_pages.append([random.randint(lower, upper) for _ in range(elements_per_page)])
        else:
            input_pages = get_manual_inputs()
            if not input_pages:
                return

        # Initialize output pages with same structure as input but empty values
        output_pages = [[0] * elements_per_page for _ in range(n_pages)]
        frames = [[0] * elements_per_page for _ in range(n_frames)]
        
        create_bars(input_pages, output_pages, frames)
        k_way_merge_sort(input_pages, output_pages, frames, n_pages, n_frames, elements_per_page, animate)
    
    else:
        raw = document["arrayInput"].value
        try:
            arr = list(map(int, raw.strip().split(',')))
        except:
            alert("Invalid input. Please enter comma-separated integers.")
            return

        if method == "bubble":
            main_create_bars(arr)
            main_bubble_sort(arr, main_animate)
        elif method == "insertion":
            main_create_bars(arr)
            main_insertion_sort(arr, main_animate)


document.bind("start_sort", on_sort_trigger)
  </script>

  <script>
    window.isAnimationRunning = false;
    window.animationPaused = false;
    let currentTimeoutId = null;

    function run_sort() {
      document.dispatchEvent(new Event("start_sort"));
    }

    function updateInputVisibility() {
        const method = document.getElementById("sortMethod").value;
        const arrayInputFields = document.getElementById("arrayInputFields");
        const kWayFields = document.getElementById("kWayFields");

        if (method === "k-way") {
            arrayInputFields.style.display = "none";
            kWayFields.style.display = "block";
        } else {
            arrayInputFields.style.display = "block";
            kWayFields.style.display = "none";
        }
    }

    function validateInteger(input) {
        const value = input.value.trim();
        const isValid = /^-?\d+$/.test(value);
        const warning = document.getElementById(input.id + "Warning");

        if (value === "") {
            input.style.borderColor = "";
            warning.style.display = "none";
            if (input.id === "n_pages") {
            updatePageInputs();
            }
        } else if (!isValid) {
            input.style.borderColor = "red";
            warning.style.display = "inline";
        } else {
            input.style.borderColor = "";
            warning.style.display = "none";
            if (input.id === "n_pages") {
            updatePageInputs();
            }
        }
    }

    function validateIntegerList(input) {
        const value = input.value.trim();
        const isValid = value.split(',').every(num => /^-?\d+$/.test(num.trim()));
        const warning = document.getElementById(input.id + "Warning");

        if (value === "") {
            input.style.borderColor = "";
            warning.style.display = "none";
        } else if (!isValid) {
            input.style.borderColor = "red";
            warning.style.display = "inline";
        } else {
            input.style.borderColor = "";
            warning.style.display = "none";
        }
    }

    function updatePageInputs() {
        const nPagesInput = document.getElementById("n_pages");
        const container = document.getElementById("pageInputsContainer");
        const warning = document.getElementById("n_pagesWarning");
        const manualCheckbox = document.getElementById("manual_populate");

        container.innerHTML = "";

        const value = nPagesInput.value.trim();
        const isValid = /^-?\d+$/.test(value);
        const nPages = parseInt(value);

        if (value === "" || !isValid || nPages <= 0 || !manualCheckbox.checked) return;

        const divider = document.createElement("hr");
        divider.style.border = "none";
        divider.style.borderTop = "1px solid lightgray";
        divider.style.marginTop = "20px";
        divider.style.marginBottom = "20px";
        container.appendChild(divider);

        for (let i = 0; i < nPages; i++) {
            const wrapper = document.createElement("div");
            wrapper.style.marginTop = "10px";

            const label = document.createElement("label");
            label.innerText = `Page ${i + 1}:`;
            wrapper.appendChild(label);

            const input = document.createElement("input");
            input.type = "text";
            input.placeholder = "Enter numbers e.g. 5,3,8,6";
            input.id = `page_${i + 1}`;
            input.oninput = function() {
                validateIntegerList(this);
            };
            input.className = "w-full p-2 border rounded mt-1";
            wrapper.appendChild(input);

            const span = document.createElement("span");
            span.className = "warning";
            span.id = `page_${i + 1}Warning`;
            span.innerText = "Please enter only comma-separated integers.";
            wrapper.appendChild(span);

            container.appendChild(wrapper);
        }
    }

    function updateSpeedDisplay() {
      const slider = document.getElementById("speedRange");
      const speedValue = document.getElementById("speedValue");
      animationSpeed = parseInt(slider.value);
      speedValue.textContent = `${animationSpeed} ms`;
    }

    function toggleAnimation() {
        const btn = document.getElementById("stopResumeBtn");
        
        if (!window.animationPaused) {
            // Stop animation
            window.animationPaused = true;
            if (currentTimeoutId) {
            clearTimeout(currentTimeoutId);
            }
            btn.textContent = "Resume";
            btn.className = "flex-1 bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded transition-colors";
        } else {
            // Resume animation
            window.animationPaused = false;
            btn.textContent = "Stop";
            btn.className = "flex-1 bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded transition-colors";
        }
    }

    window.enableStopButton = function() {
        const btn = document.getElementById("stopResumeBtn");
        btn.disabled = false;
        btn.className = "flex-1 bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded transition-colors";
        window.isAnimationRunning = true;
        window.animationPaused = false;
    }

    window.disableStopButton = function() {
        const btn = document.getElementById("stopResumeBtn");
        btn.disabled = true;
        btn.textContent = "Stop";
        btn.className = "flex-1 bg-gray-400 text-white font-bold py-2 px-4 rounded transition-colors cursor-not-allowed";
        window.isAnimationRunning = false;
        window.animationPaused = false;
    }

    function clearConsole() {
        document.getElementById("console").innerHTML = "";
    }

  </script>
</body>
</html>